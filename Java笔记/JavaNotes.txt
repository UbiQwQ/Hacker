当实例化子类时会递归调用父类中的构造方法

Java不使用stop方法停止线程：
    1.stop方法是过时的
    2.stop方法会导致代码逻辑不完整。stop方法是一种"恶意" 的中断,一旦执行stop    方法,即终止当前正在运行的线程,不管线程逻辑是否完整,这是非常危险的.

SimpleDateFormat是线程不安全

ConcurrentHashMap 使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全

形式参数(形参)可被视为local variable。形参跟局部变量一样都不能离开方法。都只有在方法内才会发生作用，也只有在方法中使用，不会再方法外可见。
形参只能被final修饰

实现接口必须实现接口的所有方法

protected 可以被同一包中的所有类访问，可以被所有子类访问
缺省 只能被同一包中的所有类访问

HashMap 键 值 都可为空

接口方法的访问权限默认都是public

子类可以继承父类的一切特性与状态（属性与方法），只是有的属性和方法子类无法访问。。

Servlet是线程不安全的，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误。

Java语言提供了八种基本类型（原始类型/primitive type）。六种数字类型（四个整型，两个浮点型），一种字符类型，还有一种布尔型。byte,short,int,long,float,double,char,boolean

处理异常通常两种方式：
1.try...catch(捕获处理机制)
2.throws(冒泡处理机制 抛出)

jar      将许多文件组合成一个jar文件
javac    编译
javah    把Java代码声明的JNI方法转化成C\C++头文件
javadoc  从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档

普通的类方法可以和类名同名，和构造方法唯一的区分就是，构造方法没有返回值

释放掉内存空间是由gc完成的，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。

final用于声明属性、方法、类。分别表示属性不可更改、方法不可覆盖、类不能继承。

垃圾回收在JVM中优先级相当低

使用垃圾收集的程序不需要明确释放对象

现代垃圾收集能够处理循环引用问题

垃圾收集能提高程序员的效率

Java反射机制的主要功能：
在运行时判断一个对象所属的类
在运行时构造一个类的对象
在运行时判断一个类所具有的成员变量与方法
在运行时调用一个对象的方法

Java默认使用Union code编码，每个字符不论英文还是中文都是占用两个字节

Java一个源程序只能有一个public类存在，且类名与文件名相同。
Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。
如果存在多个public类，程序将不知道该从哪里执行。
注意，内部类可以是public的，因为内部类是作为外部类的成员存在的

不能在static中使用this

完整的URL地址中由 协议 主机名 端口 文件 四部分组成

除构造器外，编译器禁止在其他任何方法中调用构造器

编译器将Java源代码编译成字节码class文件 类加载到JVM里面后，执行引擎把字节码转为可执行代码。执行的过程，再把可执行代码转为机器码，由底层的操作系统完成执行。

在try-catch-finally中，finally中如果有return语句，则会覆盖try块和catch块中的return语句。

switch 支持int及以下(char,short,byte),String,Enum. String 类型是Java7开始支持的

>>>无符号右移

Java中static方法不能被覆盖，因为static方法是编译时静态绑定的，而方法覆盖是基于运行时动态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

Java中类不支持多继承，因为两个继承于中一个父类的子类，被同一个子类继承时，会出现方法的引用歧义，所以Java中只支持单继承，即一个类只有一个父类。
java中的接口支持多继承，即一个子接口可以有多个父接口。接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能。


接口和抽象类的区别是什么？
接口是对动作的抽象，抽象类是对根源的抽象。
抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，大猫，小猫，来定义两个类，他们的抽象类是猫。说明，他们都是猫。猫可以奔跑，狗也可以奔跑，把“奔跑”定义成一个接口，然后让这些类去实现它。
所以，在高级语言上，一个类只能继承一个类（抽象类）(正如猫不可能同时是动物和植物)，但是可以实现多个接口(吃奔跑口、跳跃接口)。
区别如下:
1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
2、抽象类要被子类继承，接口要被类实现。
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果。
7、抽象类里可以没有抽象方法。
8、如果一个类里有抽象方法，那么这个类只能是抽象类。
9、抽象方法要被实现，所以不能是静态的，也不能是私有的。
10、接口可继承接口，并可多继承接口，但类只能单根继承。


构造函数必须与类名同名，而且不能有返回类型。而方法是可以与类名同名的，但是必须声明返回数据类型。


根类 Object 的方法：equals() getClass() hasCode() notify() notifyAll() toString() wait()


HashSet子类依靠 hashCode(),equals()方法区分重复元素
HashSet添加元素，首先比较hash值，如果没有相同的hash-->添加，如果有相同的hash则比较equals如果不同则添加，否则不添加。


当涉及 静态初始化代码块、构造代码块、构造方法 并且涉及到继承时，按照如下顺序执行：
1.执行父类的静态代码
2.执行子类的静态代码
3.执行父类的构造代码块
4.执行父类的构造函数
5.执行子类的构造代码块
6.执行子类的构造函数


静态变量只能在类主体中定义，不能在方法中定义！


运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区以及方法区中的运行时常量池

1.程序计数器： 线程私有，是当前线程所执行的字节码的行号指示器，如果线程正执行一个java方法，计数器记录正在执行的虚拟机字节码指令的地址，如果线程正在执行的是Native方法，则计数器值为空;

2.虚拟机栈： 即栈区， 线程私有 ，为虚拟机执行 Java 方法（字节码）服务，每个方法在执行的时会创建一个栈帧用于存放局部变量表、操作数栈、动态链接和方法出口等信息，每个方法的调用直至执行完成对应于栈帧的入栈和出栈;

3.本地方法栈： 为虚拟机使用的 N ative 方法服务，也是 线程私有;

4.Java 堆： 在虚拟机启动时创建， 线程共享 ，唯一目的是存放对象实例，是垃圾收集器管理的主要区域――” GC 堆“，可以细分为新生代和老年代，新生代又可以细分为 Eden 空间、 From Survivor 空间和 To Survivor 空间；物理上可以不连续，但逻辑上连续，可以选择固定大小或者扩展;

5.方法区： 线程共享 ，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。被称为“永久代”，是因为 H otSpot 虚拟机的设计团队把 GC 分代收集扩展到方法区，即使用永久代来实现方法区，像 GC 管理 Java 堆一样管理方法区，从而省去专门为方法区编写内存管理代码，内存回收目标是针对常量池的回收和堆类型的卸载;

6.运行时常量池： 线程共享 ，是方法区的一部分， C lass 文件中存放编译期生成的各种字面量和符号引用，类加载后进入方法区的运行时常量池中.



什么是多态？
多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。
多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。
运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。


最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。






































