当实例化子类时会递归调用父类中的构造方法

Java不使用stop方法停止线程：
    1.stop方法是过时的
    2.stop方法会导致代码逻辑不完整。stop方法是一种"恶意" 的中断,一旦执行stop    方法,即终止当前正在运行的线程,不管线程逻辑是否完整,这是非常危险的.

SimpleDateFormat是线程不安全

ConcurrentHashMap 使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全

形式参数(形参)可被视为local variable。形参跟局部变量一样都不能离开方法。都只有在方法内才会发生作用，也只有在方法中使用，不会再方法外可见。
形参只能被final修饰

实现接口必须实现接口的所有方法

protected 可以被同一包中的所有类访问，可以被所有子类访问
缺省 只能被同一包中的所有类访问

HashMap 键 值 都可为空

接口方法的访问权限默认都是public

Java中的变量和基本类型的值存放于栈内存，而new出来的对象本身存放在堆内存中，指向对象的引用存放在栈内存。

子类可以继承父类的一切特性与状态（属性与方法），只是有的属性和方法子类无法访问。。

Servlet是线程不安全的，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误。

JVM可通过ClassLoader寻找和装载class文件

Java语言提供了八种基本类型（原始类型/primitive type）。六种数字类型（四个整型，两个浮点型），一种字符类型，还有一种布尔型。byte,short,int,long,float,double,char,boolean

处理异常通常两种方式：
1.try...catch(捕获处理机制)
2.throws(冒泡处理机制 抛出)

jar      将许多文件组合成一个jar文件
javac    编译
javah    把Java代码声明的JNI方法转化成C\C++头文件
javadoc  从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档

普通的类方法可以和类名同名，和构造方法唯一的区分就是，构造方法没有返回值

释放掉内存空间是由gc完成的，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。

final用于声明属性、方法、类。分别表示属性不可更改、方法不可覆盖、类不能继承。

垃圾回收在JVM中优先级相当低

使用垃圾收集的程序不需要明确释放对象

现代垃圾收集能够处理循环引用问题

垃圾收集能提高程序员的效率

Java反射机制的主要功能：
在运行时判断一个对象所属的类
在运行时构造一个类的对象
在运行时判断一个类所具有的成员变量与方法
在运行时调用一个对象的方法

Java默认使用Union code编码，每个字符不论英文还是中文都是占用两个字节

Java一个源程序只能有一个public类存在，且类名与文件名相同。
Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。
如果存在多个public类，程序将不知道该从哪里执行。
注意，内部类可以是public的，因为内部类是作为外部类的成员存在的

不能在static中使用this

完整的URL地址中由 协议 主机名 端口 文件 四部分组成

除构造器外，编译器禁止在其他任何方法中调用构造器

编译器将Java源代码编译成字节码class文件 类加载到JVM里面后，执行引擎把字节码转为可执行代码。执行的过程，再把可执行代码转为机器码，由底层的操作系统完成执行。

在try-catch-finally中，finally中如果有return语句，则会覆盖try块和catch块中的return语句。






















