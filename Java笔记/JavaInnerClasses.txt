Java 常见的内部类有哪几种，简单说说其特征？
静态内部类、成员内部类、方法内部类（局部内部类）、匿名内部类。
静态内部类是定义在另一个类里面用 static 修饰 class 的类，静态内部类不需要依赖于外部类（与类的静态成员属性类似）且无法使用其外部类的非 static 属性或方法（因为在没有外部类对象的情况下可以直接创建静态内部类的对象，如果允许访问外部类的非 static 属性或者方法就会产生矛盾）。

成员内部类是没有用 static 修饰且定义在在外部类类体中的类，是最普通的内部类，可以看做是外部类的成员，可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员），而外部类无法直接访问成员内部类的成员和属性，要想访问必须得先创建一个成员内部类的对象然后通过指向这个对象的引用来访问；当成员内部类拥有和外部类同名的成员变量或者方法时会发生隐藏现象（即默认情况下访问的是成员内部类的成员，如果要访问外部类的同名成员需要通过 OutClass.this.XXX 形式访问）；成员内部类的 class 前面可以有 private 等修饰符存在。

方法内部类（局部内部类）是定义在一个方法里面的类，和成员内部类的区别在于方法内部类的访问仅限于方法内；方法内部类就像是方法里面的一个局部变量一样，所以其类 class 前面是不能有 public、protected、private、static 修饰符的，也不可以在此方法外对其实例化使用。

匿名内部类是一种没有构造器的类（实质是继承类或实现接口的子类匿名对象），由于没有构造器所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调，匿名内部类在编译的时候由系统自动起名为 OutClass$1.class，一般匿名内部类用于继承其他类或实现接口且不需要增加额外方法的场景（只是对继承方法的实现或是重写）；匿名内部类的 class 前面不能有 pravite 等修饰符和 static 修饰符；匿名内部类访问外部类的成员属性时外部类的成员属性需要添加 final 修饰（1.8 开始可以不用）。




Java 中内部类有什么好处（即 Java 的内部类有什么作用）？

具体好处如下:
内部类可以很好的实现隐蔽，一般的非内部类，是不允许有 private 与 protected 等权限的，但内部类（除过方法内部类）可以通过这些修饰符来实现隐藏。
内部类拥有外部类的的访问权限（分静态非静态情况），通过这一特性可以比较好的处理类之间的关联性，将一类事物的流程放在一起内部处理。
通过内部类可以实现多重继承，java 默认是单继承，我们可以通过多个内部类继承实现多个父类，接着由于外部类完全可访问内部类，所以就实现了类似多继承的效果。
通过内部类可以避免修改接口而实现同一个类中两种同名方法的调用（譬如你的类 A 中有一个参数为 int 的 func 方法，现在类 A 需要继承实现一个接口 B，而接口 B 中也有一个参数为 int 的 func 方法，此时如果直接继承实现就会出现同名方法矛盾问题，这时候如果不允许修改 A、B 类的 func 方法名则可以通过内部类来实现 B 接口，因为内部类对外部类来说是完全可访问的）。





静态内部类可以有静态成员或者静态方法，而非静态内部类不能有静态成员或者静态方法,
除 static 内部类外，不能直接在内部类中声明 static 成员（static 常量除外）。

当内部类不需要访问外围类对象的时候，应该使用静态内部类。
静态内部类，只能访问外部类的静态成员。


非静态内部类里面为什么不能有静态属性和静态方法？

static 类型的属性和方法在类加载的时候就会存在于内存中，要使用某个类的 static 属性或者方法的前提是这个类已经加载到 JVM 中，非 static 内部类默认是持有外部类的引用且依赖外部类存在，所以如果一个非 static 的内部类一旦具有 static 的属性或者方法就会出现内部类未加载时却试图在内存中创建内部类的 static 属性和方法，这自然是错误的，类都不存在（没被加载）却希望操作它的属性和方法。从另一个角度讲非 static 的内部类在实例化的时候才会加载（不自动跟随主类加载），而 static 的语义是类能直接通过类名来访问类的 static 属性或者方法，所以如果没有实例化非 static 的内部类就等于非 static 的内部类没有被加载，所以无从谈起通过类名访问 static 属性或者方法。


Java 中非静态内部类和静态内部类有什么区别？

常见的区别如下:
非静态内部类默认持有外部类的引用，静态内部类不存在该特性。
非静态内部类中不能定义静态成员或者方法，静态内部类中可以随便定义。
非静态内部类可以直接访问外部类的成员变量或者方法，静态内部类只能直接访问外部类的静态成员或者方法（实质是持有外部类名）。
非静态内部类可以定义在外部类的任何位置（方法里外均可，在方法外面定义的内部类的 class 访问类型可以是 public、protected 等，方法里的只能是默认 class，类似局部变量），静态内部类只能定义在外部类中最外层，class 修饰符可以是 public、protected 等。
非静态内部类创建实例时必须先创建外部类实例，静态内部类不依赖外部类实例。
静态方法中定义的内部类是静态内部类（这时不能在类前面加 static 关键字），静态方法中的静态内部类与普通方法中的内部类使用类似，除了可以直接访问外部类的 static 成员变量或者方法外还可以访问静态方法中的局部变量（java 1.8 以前局部变量前必须加 final 修饰符）。




内部类可用 abstract 修饰符定义为抽象类，也可以用 private 或 protected 定义。


使用匿名内部类时必须是继承一个类或实现一个接口（二者不可兼得且只能继承一个类或者实现一个接口）。
匿名内部类中是不能定义构造函数的，如需初始化可以通过构造代码块处理。
匿名内部类中不能存在任何的静态成员变量和静态方法。
匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。
匿名内部类不能是抽象类，必须要实现继承的类或者实现接口的所有抽象方法。
匿名内部类无法通过构造方法初始化，所以我们只能通过构造代码块进行初始化。
匿名内部类没有名称，因此在创建匿名内部类对象时，new运算符后是超类或接口的名称，其后面的{}内部为匿名类的定义。
匿名类对象的创建与匿名内部类的定义是在一起完成的。


局部内部类和成员内部类的区别在于,前者作用域仅局限于方法内。
局部内部类有一个优势，即对外部世界可以完全地隐藏起来。
局部内部类不能用public、protected、private以及static修饰符的。








